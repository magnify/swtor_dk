<?php
/**
 * This is the og_content_type_admin module for use with Organic Groups.
 *
 * <p>This file contains information on the og_content_type_admin module. This module adds
 * to OG the ability to restrict which content types can be used by each group.</p>
 * <p>In the site admin interface, the admin can select which content types are available
 * outside of groups. The admin can also set the default content types that are available
 * to new user-created groups. The admin can set which content types are available to individual
 * groups as well. Lastly, the admin can set content types as 'required' - see below for more on
 * that.</p>
 * <p>So far as the OG owner is concerned, (s)he will see a listing of content types that have
 * been made available to the group. The types can be individually (de)activated so that the group
 * doesn't have to use types the owner doesn't feel the group needs. However, the owner can always
 * create content of these deactivated types, and users can view that content. Those types that
 * were marked as 'required' by the site admin will always be usable by the group members and
 * cannot be deactivated by the group owner.</p>
 *
 * @version $Id: og_content_type_admin.module,v 1.15.2.11 2009/10/15 11:04:25 paulbooker Exp $;
 * @package OG_CTA
 * @category NeighborForge
 * @author Ryan Constantine
 * @filesource
 * @license http://www.gnu.org/licenses/gpl.txt GNU_GENERAL_PUBLIC_LICENSE
 * @link none yet
 * TODO it seems that changing the title of the Create content menu item changes in the menu table,
 * but doesn't change the text displayed; why?
 * TODO add a button on the site-wide portion of assignment page to delete an entry from node_type
 * since our list of available content_types comes from there (node_get_types) and it isn't accurate.
 * only show the button if the "module_invoke_all('node_info');" doesn't have a matching entry in
 * the result from "node_get_types". this will also place buttons next to user-created content types,
 * but I don't see how to differentiate. this will still leave "content_type_XX" tables that probably
 * shouldn't be there.
 */

/**
 * Constants to indicate whether a content type is assigned to a group.
 */
define('NOT_ASSIGNED_TO_GROUP', 0);
define('ASSIGNED_TO_GROUP', 1);

/**
 * Constants to indicats whether a content type is activated/deactivated/required.
 */
define('DEACTIVATED', 0);
define('ACTIVATED', 1);
define('REQUIRED', 2);

/**
 * Implementation of hook_help
 *
 * Display help and module information
 * @param string section which section of the site we're displaying help
 * @return help text for section
 */
function og_content_type_admin_help($path, $arg) {

  $output = '';
  switch ($path) {
    case "admin/help#og_content_type_admin":
      $output = '<p>' . t("Allows the restriction of the use of content types by organic groups.
Site admins can setup which content types are available site-wide (outside groups), to new groups, and can assign types to individual groups. 
Group owners can then activate or deactivate the types for use in their group."). '</p>';
      break;
  }

  return $output;
} // function og_content_type_admin_help()

/**
 * Implementation of hook_perm
 *
 * Valid permissions for this module
 * @return array An array of valid permissions for the onthisdate module
 */
function og_content_type_admin_perm() {
  return array('administer og content types');
} // function og_content_type_admin_perm()

/**
 * Implementation of hook_menu
 *
 * The menu item(s) for this module.
 * @param boolean $may_cache Whether the menu item can be cached or not
 * @return array An array of arrays, to add menu entries to the system menu.
 */
function og_content_type_admin_menu() {
  global $user, $_menu;
  $items = array();

  $items['admin/og/og_content_types'] = array( //adminster which content types are assigned to which groups and the site in general
  'title' => t('OG Content Types'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('og_content_type_admin_main'),
  'access arguments' => array('administer og content types'),
  'description' => t('Administer which content types can be used by site-wide and by each Organic Group.'),
  'type' => MENU_NORMAL_ITEM,
  );
     
  $items['admin/og/og_content_types/overview'] = array( //tab to take us to main administer page
  'title' => t('Overview'),
  'access arguments' => array('administer og content types'),
  'type' => MENU_DEFAULT_LOCAL_TASK,
  'weight' => -10,
  );
     
  $items['admin/og/og_content_types/admin'] = array( //assign and/or make required content types for each group under administration
  'title' => t('Assign Content Types'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('og_content_type_admin_admin'),
  'access arguments' => array('administer og content types'),
  'type' => MENU_LOCAL_TASK,
  );

  $items['admin/og/og_content_types/delete'] = array( //delete a group from separate content type management and revert to defaults
  'title' => t('Delete'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('og_content_type_admin_confirm_delete'),
  'access arguments' => array('administer og content types'),
  'type' => MENU_CALLBACK,
  );
     
  $items['node/%/ogct'] = array( 
  'title' => t('Content Types'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('og_content_type_admin_owner', 1),
  'access callback' =>  '_og_content_type_admin_is_admin_access_callback',
  'access arguments' => array(1),
  'weight' => 6,
  'type' => MENU_LOCAL_TASK
  );
  return $items;
} // function og_content_type_admin_menu()

function _og_content_type_admin_is_admin_access_callback($nid){
  $group = node_load($nid);
  $return  = (isset($group->og_selective) && _og_content_type_admin_is_admin($group)) ? TRUE : FALSE;
  return $return;
}	

/**
 * Implementation of hook_theme().
 */
function og_content_type_admin_theme() {
  return array(
    'og_content_type_admin_main' => array(
      'arguments' => array('form' => NULL),
    ),
    'og_content_type_admin_admin' => array(
      'arguments' => array('form' => NULL),
    ),
    'og_content_type_admin_owner' => array(
      'arguments' => array('form' => NULL),
    ),
  );
} 

/**
 * Implementation of hook_og_create_links().
 */
function og_content_type_admin_og_create_links($group) {
  global $user;
  $links = array();
  if ($group) {
    if (_og_content_type_admin_is_admin($group)) {
      $links[] = l(t('Manage group content types'), "node/$group->nid/ogct", array('title' => t('Lets you decide which content types your group\'s users can create.')));
    }
  }
  return $links;
}

//Site administration section---------------------------------------------------------------------------------
//This section is only for administration forms and form processing

/**
 * Callback function: Add groups to administer the content types for.
 *
 * @param integer $gid
 *   The GID of the group.
 * @return mixed
 */
function og_content_type_admin_main($gid = NULL) {
  if ($admin = user_access('administer og content types')) {
    $options = og_all_groups_options();
    $added = _og_content_type_admin_get_added();
    foreach ($added as $group_id => $name) {//remove from the select, groups we're already working with
      if (array_key_exists($group_id, $options)) {
        unset($options[$group_id]);
      }
    } 
    if (count($options)) {
      $form['group'] = array(
      '#type' => 'select',
      '#title' => t('Groups'),
      '#options' => $options,
      );
      $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add group'),
      );
    }  
  }
  return $form;
}

/**
 * Validate the group name before adding or saving it
 *
 * @param string $form
 * @param mixed $form_state
 * @return string
 */
function og_content_type_admin_main_validate($form, &$form_state) {
  $form_values = $form_state['values']; 
  if ($form_values['group']) {
    //make sure the user isn't injecting something not on the list.
    $check_options = _og_content_type_admin_get_added();
    if ($form_values['op'] == t('Add group')) {
      if (array_key_exists($form_values['group'], $check_options)) {
        form_set_error('group', t('The group name %name is already added. Please choose another group name.', array('%name' => $form_values['group']['name'])));
      }
    }
  }
  else {
    form_set_error('name', t('You must specify a valid group name.'));
  }
}

/**
 * Submit the group name and id to be added to the database.
 *
 * @param string $form
 * @param mixed $form_state
 * @return string
 */
function og_content_type_admin_main_submit($form, &$form_state) {
  $form_values = $form_state['values']; 
  if ($form_values['op'] == t('Add group')) {
    $all_groups = og_all_groups_options();
    db_query("INSERT INTO {og_content_type_admin} (gid, name, types_allowed, types_active) VALUES (%d, '%s', '', '')", $form_values['group'], $all_groups[$form_values['group']]);
    drupal_set_message(t('The group has been added.'));
  }
  $form_state['redirect'] = 'admin/og/og_content_types';
}

/**
 * Theme for the add page of the main function.
 *
 * <p>This lists all of the current account types with links to edit them or their assigned roles, followed with
 * a field and button to add a new account type name to the list.</p>
 * @param mixed $form
 * @return mixed
 */
function theme_og_content_type_admin_main($form) {
  $header = array(t('Group'), array('data' => t('Operations'), 'colspan' => 2));
  $added_groups = _og_content_type_admin_get_added();
  //keep the sitewide settings at the top...
  $name = $added_groups[-1];
  $admin = l(t('assign content types'), 'admin/og/og_content_types/admin/' . -1);
  $rows[] = array($name, $admin, NULL);
  //...with the default group settings next...
  $name = $added_groups[0];
  $admin = l(t('assign content types'), 'admin/og/og_content_types/admin/' . 0);
  $rows[] = array($name, $admin, NULL);
  //...then finish the rest in alphabetical order
  foreach ($added_groups as $gid => $name) {
    if ($gid != -1 && $gid != 0) {
      $admin = l(t('assign content types'), 'admin/og/og_content_types/admin/' .$gid);
      $delete = l(t('delete'), 'admin/og/og_content_types/delete/' .$gid);
      $rows[] = array($name, $admin, $delete);
    }
  }
  $rows[] = array(drupal_render($form['group']), array('data' => drupal_render($form['submit']), colspan => 2));

  $output = drupal_render($form);
  $output .= theme('table', $header, $rows);

  return $output;
}

/**
 * Returns a confirmation page for deleting a group from the content type admin table.
 *
 * @param integer $gid Value of group to be deleted; passed in from path.
 * @return array $form The GID is passed to the submit.
 */
function og_content_type_admin_confirm_delete(&$form_state, $gid= NULL) {
  if ($gid == NULL) {
    drupal_goto('admin/og/og_content_types');
    return;
  }
  $sql = "SELECT octa.gid, octa.name FROM {og_content_type_admin} octa WHERE octa.gid = %d";
  $result = db_fetch_object(db_query($sql, $gid));
  $form['name'] = array('#type' => 'value', '#value' => $result->name);
  $form['gid'] = array('#type' => 'value', '#value' => $gid);
  $return_address = 'admin/og/og_content_types';
  $form = confirm_form($form, t('Are you sure you want to delete the group %name from the content type manager?',
    array('%name' => $result->name)), $return_address,
    t('Deleting a group here will revert the content types associated with it to the defaults. This action cannot be undone.'), t('Delete'), t('Cancel'));
    return $form;
}

/**
 * Implementation of forms api _submit call. Deletes a group from the og_content_type_admin table after confirmation.
 *
 * @param string $form
 * @param mixed $form_state
 * @return string $return_address The path to return to after we've deleted the record.
 */
function og_content_type_admin_confirm_delete_submit($form, &$form_state) {
  $form_values = $form_state['values']; 
  $dbquery = db_query('DELETE FROM {og_content_type_admin} WHERE gid = %d', $form_values['gid']);
  if ($dbquery) {
    drupal_set_message(t('The group %gid has been removed from the content type admin table.', array('%gid' => $form_values['name'])));
    watchdog('content', t('og_content_type_admin: deleted %gid.', array('%gid' => $form_values['name'])));
  }
  $form_state['redirect'] = 'admin/og/og_content_types';
}

/**
 * Callback function: Assign or Require content types to groups.
 *
 * @param
 * @return array $form
 */
function og_content_type_admin_admin(&$form_state, $gid = NULL) {
  if ($gid == NULL) {
    $sql = "SELECT octa.gid, octa.name, octa.types_allowed, octa.types_active FROM {og_content_type_admin} octa ORDER BY octa.name ASC";
    $results = db_query($sql);
    $coll = 1;
  }
  else { 
    $sql = "SELECT octa.gid, octa.name, octa.types_allowed, octa.types_active FROM {og_content_type_admin} octa WHERE octa.gid = %d";
    $results = db_query($sql, $gid); 
    $coll = 0;
  }
  //these are the master lists, used when we haven't filled in any values for a particular $gid
  $node_types_types = node_get_types();
  if (module_exists('nf_registration_mod')) {
    $pageroute_types = _nf_registration_mod_menu_status();
    foreach ($pageroute_types as $typea => $nums) {
      if ($nums[1] == 48) {
        if (isset($node_types_types[$typea])) {
          unset($node_types_types[$typea]);
        }
      }
    }
  }

  $form['groups'] = array('#tree' => TRUE);
  while ($result = db_fetch_object($results)) { //grab a group that we're monitoring
    $form['groups'][$result->name] = array(
    '#tree' => TRUE,
    );
    $form['groups'][$result->name]['coll'] = array('#value' => $coll);
    $form['groups'][$result->name]['gid'] = array('#value' => $result->gid, '#type' => 'hidden');  
    if ($result->gid != -1) {//default group
      $assigned_status = unserialize($result->types_allowed);
      $required_status = unserialize($result->types_active);
      foreach ($node_types_types as $type) {
        if (!og_is_omitted_type($type->type) && !og_is_group_type($type->type)) {
          $form['groups'][$result->name][$type->type]['name'] = array('#value' => t($type->name));
          $form['groups'][$result->name][$type->type]['name2'] = array(
            '#type' => 'value',
            '#value' => t($type->name)
          );
          $form['groups'][$result->name][$type->type]['allowed'] = array(
          '#type' => 'checkbox',
          '#return_value' => ASSIGNED_TO_GROUP,
            );
          if ($assigned_status[$type->type] != ASSIGNED_TO_GROUP) {
            $form['groups'][$result->name][$type->type]['allowed']['#default_value'] = NOT_ASSIGNED_TO_GROUP;
          }
          else {
            $form['groups'][$result->name][$type->type]['allowed']['#default_value'] = ASSIGNED_TO_GROUP;
          }
          $form['groups'][$result->name][$type->type]['required'] = array(
            '#type' => 'checkbox',
            '#return_value' => REQUIRED,
            );
          //although here we only use the values 0 & 2, since we use 1 elsewhere (the group owner settings), take care at submission
          //to not DEACTIVATE already-ACTIVATED types; i.e. if we're not setting it to two, respect that it might already be a 1;
          //see og_content_type_admin_admin_submit
          if ($required_status[$type->type] != REQUIRED) {
            $form['groups'][$result->name][$type->type]['required']['#default_value'] = DEACTIVATED;
          }
          else {
            $form['groups'][$result->name][$type->type]['required']['#default_value'] = REQUIRED;
          }
          if ($result->name == 'Default') {
            $form['groups'][$result->name][$type->type]['propagate']['submit'] = array(
              '#type' => 'submit',
              '#value' => t('Allow "' .$type->name. '" in all groups'),
            );
          }
        }
      }
    }
    else { //repeat of above, but since we're looking at site-wide use of content types, don't throw out group-exempt types
      $assigned_status = unserialize($result->types_allowed);
      $required_status = unserialize($result->types_active);
      foreach ($node_types_types as $type) {
        $form['groups'][$result->name][$type->type]['name'] = array('#value' => t($type->name));
        $form['groups'][$result->name][$type->type]['allowed'] = array(
          '#type' => 'checkbox',
          '#disabled' => TRUE,
          '#value' => ASSIGNED_TO_GROUP,
          );
          /*if ($assigned_status[$type->type] != ASSIGNED_TO_GROUP) {
            $form['groups'][$result->name][$type->type]['allowed']['#default_value'] = NOT_ASSIGNED_TO_GROUP;
          } else {
          $form['groups'][$result->name][$type->type]['allowed']['#default_value'] = ASSIGNED_TO_GROUP;
          }*/
        $form['groups'][$result->name][$type->type]['required'] = array(
          '#type' => 'checkbox',
          '#default_value' => $required_status[$type->type],
          '#return_value' => REQUIRED,
          );
          if ($required_status[$type->type] != REQUIRED) {
            $form['groups'][$result->name][$type->type]['required']['#default_value'] = DEACTIVATED;
          }
          else {
            $form['groups'][$result->name][$type->type]['required']['#default_value'] = REQUIRED;
          }
      }
    }
    //TODO add a checkbox for each monitored group - place result in a new field in the DB table called 'hide', as in 'hide UI from group owner';
    // this will allow us to restrict changes for each group, rather than globally
    $form['no_change'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('og_content_type_admin_no_change', 0),
      '#title' => 'Disallow changes by all group owners',
      '#description' => 'Hide the group owner interface so they can\'t change their group\'s settings. 
This has the effect of setting all <em>ALLOWED</em> content types to <em>ACTIVATED</em> since the group owner will no longer be able to set them. 
This affects all groups. Once checked and saved, unchecking (and saving) will not <em>DEACTIVATE</em> any type.',
      );
  }
  //create a submit button
  $form['submit'] = array('#type' => 'submit', '#value' => t('Save assignments'));

  return $form;
} //function og_content_type_admin_admin()

/**
 * Submit the group/content-type associations for storage
 *  
 * @param string $form_id
 * @param mixed $form_values
 */
function og_content_type_admin_admin_submit($form, &$form_state) {
  $form_values = $form_state['values']; 
  $propagate_type = NULL;
  if (strstr($form_values['op'], 'Allow')) {
    $startpos = strpos($form_values['op'], '"');
    $endpos = strrpos($form_values['op'], '"');
    $length = $endpos - $startpos - 1;
    $propagate_type = substr($form_values['op'], ($startpos + 1), $length);
    foreach (element_children($form_values['groups']) as $group) {
      foreach (element_children($form_values['groups'][$group]) as $type) {
        if ($form_values['groups'][$group][$type]['name2'] == $propagate_type) {
          if ($form_values['groups'][$group] != 'Site Wide') {
            $form_values['groups'][$group][$type]['allowed'] = ASSIGNED_TO_GROUP;
          }
        }
      }
    }
  }
  //if the required value of a particular content type is DEACTIVATED (0) and not REQUIRED (2),
  //make sure it isn't already set to ACTIVATED(1) before saving it as DEACTIVATED(0) unless we're looking at site-wide
  $error = FALSE;
  foreach (element_children($form_values['groups']) as $group) {
    //grab the stored 'required/activated' data for comparison
    $sql = "SELECT octa.types_active FROM {og_content_type_admin} octa WHERE octa.name = '%s'";
    $results = db_fetch_object(db_query($sql, $group));
    $required_status = unserialize($results->types_active);
    
    //isolate the submitted values per group and ready them for storage
    foreach (element_children($form_values['groups'][$group]) as $type) {
      if ($type != 'gid') {
        if ($form_values['groups'][$group][$type]['required'] == REQUIRED) { //required is king, so base other decisions on it
          $required[$group][$type] = REQUIRED;
          $assigned[$group][$type] = ASSIGNED_TO_GROUP; // it can't be required and not assigned to the group!!!
        }
        elseif ($required_status[$type] == ACTIVATED) { //check stored value here since this form can't set this to ACTIVATED
          if (($form_values['groups'][$group][$type]['allowed'] == ASSIGNED_TO_GROUP) && ($form_values['groups'][$group]['gid'] == -1)) {
            $required[$group][$type] = DEACTIVATED; //We can't set this to ACTIVATED in any way for site-wide, so if it isn't REQUIRED...
            $assigned[$group][$type] = ASSIGNED_TO_GROUP; //then it must be DEACTIVATED
          }
          elseif ($form_values['groups'][$group][$type]['allowed'] == ASSIGNED_TO_GROUP) {
            $required[$group][$type] = ACTIVATED; //since we've assigned it to the group and the group owner activated it...
            $assigned[$group][$type] = ASSIGNED_TO_GROUP; //go ahead and store the values as such
          }
          else {
            $required[$group][$type] = DEACTIVATED; //we haven't assigned it to the group, or we just unassigned it, so...
            $assigned[$group][$type] = NOT_ASSIGNED_TO_GROUP; //make sure to deactivate it
          }
        }
        else { //it's currently deactivated; make sure assigned groups are enabled if we don't allow the group owner to make changes
          //drupal_set_message('<pre>Form values: ' .print_r($form_values, TRUE). '</pre>');
          if ((($form_values['no_change'] == 1) && ($form_values['groups'][$group][$type]['allowed'] == ASSIGNED_TO_GROUP)) || (($form_values['groups'][$group]['gid'] == 0) && ($form_values['groups'][$group][$type]['allowed'] == ASSIGNED_TO_GROUP))) {
            $required[$group][$type] = ACTIVATED;
            $assigned[$group][$type] = ASSIGNED_TO_GROUP;
          }
          else {
            $required[$group][$type] = DEACTIVATED; //it's not required, and the group owner hasn't activated it, so save it's...
            $assigned[$group][$type] = $form_values['groups'][$group][$type]['allowed']; //deactivated state and whatever we set 'Assigned' to
          }
        }
      }
    }  
    $query = db_query("UPDATE {og_content_type_admin} SET types_allowed = '%s', types_active = '%s' WHERE name = '%s'",
      serialize($assigned[$group]), serialize($required[$group]), $group);
    if (!$query) {
      $error = TRUE;
    }
  }
  if (isset($form_values['no_change'])) {
    variable_set('og_content_type_admin_no_change', $form_values['no_change']);
  }
  else {
    variable_set('og_content_type_admin_no_change', 0);
  }
  
  if ($error) {
    drupal_set_message(t('There was an error processing the data. Try again, or contact your site administrator.'), 'error');
  }
  else {
    drupal_set_message(t('The changes have been saved. The group owner must now activate content types for them to be used in that group.'));
  }
} //function og_content_type_admin_admin_submit()

/**
 * Theme function to display the group/content-type association grid
 * 
 * @param $form The form for the table.
 * @return string An HTML string representing the table.
 */
function theme_og_content_type_admin_admin($form) {
  //header is common for each group we work with
  
  $output = '';
  $output_array = array();
  foreach (element_children($form['groups']) as $key) { //grab a group
    $rows = array();
    if (is_array($form['groups'][$key])) {
      foreach (element_children($form['groups'][$key]) as $type) { //grab a content type
        if (($type != 'coll') && ($type != 'gid')) {
          $row = array();
          $row[] = array('data' => drupal_render($form['groups'][$key][$type]['name']), 'class' => 'role'); //re-use the role CSS style
          $row[] = array('data' => drupal_render($form['groups'][$key][$type]['allowed']), 'align' => 'left', 'title' => t($type));
          $row[] = array('data' => drupal_render($form['groups'][$key][$type]['required']), 'align' => 'left', 'title' => t($type));
          if ($key == 'Default') {
            $row[] = array('data' => drupal_render($form['groups'][$key][$type]['propagate']), 'align' => 'left');
          }
          $rows[] = $row;
        }
      }
    }
    if ($key == 'Default') {
      $header = array();
      $header[] = t('Content Types');
      $header[] = t('Allow');
      $header[] = t('Require');
      $header[] = t('Propagate');
    }
    else {
      $header = array();
      $header[] = t('Content Types');
      $header[] = t('Allow');
      $header[] = t('Require');
    }
    $fieldset = array(
      '#type' => 'fieldset',
      '#value' => theme('table', $header, $rows, array('id' => 'roles')),// re-use the roles CSS style
      '#title' => $key,
      '#description' => t('If you <em>REQUIRE</em> that a group use a content type, it will automatically be allowed; 
no need to check the <em>ALLOW</em> boxes too.'),
      '#collapsible' => TRUE,
      '#collapsed' => ($form['groups'][$key]['coll']['#value'] == 1) ? TRUE : FALSE,
      '#weight' => 0,
      );
    //$fieldset['gid'] = $form['groups'][$key]['gid'];
    if ($key == 'Site Wide') {
      $fieldset['#weight'] = -10;
      $fieldset['#description'] = t('Since you are the group owner of the entire site, it doesn\'t make sense to have more than one control.
 <em>REQUIRE</em> the content types you would like to have activated at the site-wide level.');
      $output_array[$fieldset['#weight']] = theme('fieldset', $fieldset);
    }
    elseif ($key == 'Default') {
      $fieldset['#weight'] = -8;
      $fieldset['#description'] .= t(' For the <em>Default</em> group, all <em>ALLOWED</em> content types will also be <em>ACTIVATED</em>.
Additionally, clicking any of the <em>Allow TYPE in all groups</em> buttons will submit the form and check all <em>ALLOWED</em> boxes in every group except <em>Site Wide</em>.
This is particularly useful if you\'ve added a content type after many group admins have customized their type usage.');
      $output_array[$fieldset['#weight']] = theme('fieldset', $fieldset);
    }
    else {
      $output_array[] = theme('fieldset', $fieldset);
    }
    unset ($form['groups'][$key]['coll']);//if we don't unset these, drupal_render lists 1's at the end of the page
  }
  
  ksort($output_array);
  foreach ($output_array as $out) {
    $output .= $out;
  }
  
  $output .= drupal_render($form);
  return $output;
} //function theme_og_content_type_admin_admin()

//Group owner administration section----------------------------------------------------------------------
//This section is only for the group content type administration form and its processing

/**
 * Let the group owner decide which content types his members can use.
 * 
 * @param object $group
 * @return array $form
 */
function og_content_type_admin_owner(&$form_state, $nid) {  //print "nid = ".$nid;
  global $user;
  $group = node_load($nid);  //print_r($group); 
  og_set_theme($group->nid);
  og_set_group_context($group);
  
  $sql = "SELECT octa.gid, octa.name, octa.types_allowed, octa.types_active FROM {og_content_type_admin} octa WHERE octa.gid = %d";
  if (!$result = db_fetch_object(db_query($sql, $group->nid))) { //if the group isn't one we're monitoring yet, get the defaults
    $result = db_fetch_object(db_query($sql, 0));
  }
  $form['group'] = array(
  '#tree' => TRUE,
  );
  $assigned = unserialize($result->types_allowed);
  $activated_status = unserialize($result->types_active);
  foreach ($assigned as $type => $value) {
    if ($value) {
      $form['group'][$type] = array(
        '#type' => 'checkbox',
        );
        if ($activated_status[$type] != REQUIRED) {
        $form['group'][$type]['#default_value'] = $activated_status[$type];
        $form['group'][$type]['#return_value'] = ACTIVATED;
      }
      else {
        $form['group'][$type]['#value'] = REQUIRED;
        $form['group'][$type]['#return_value'] = REQUIRED;
        $form['group'][$type]['#disabled'] = TRUE;
        $form['group'][$type]['#title'] = t('This is required by the site admin.');
      }
    }
    else {
      $form['group'][$type] = array(
        '#type' => 'hidden',
        '#value' => DEACTIVATED,
        );
    }
  }
  //create a submit button
  $form['submit'] = array('#type' => 'submit', '#value' => t('Save assignments'));
  
  // Breadcrumb navigation:
      $breadcrumb[] = l(t('Home'), NULL);
      $breadcrumb[] = l(t('Groups'), 'og');
      $breadcrumb[] = l(t("@title", array('@title' => $group->title)), 'node/'.$group->nid);
      drupal_set_breadcrumb($breadcrumb); 
  return $form;
} // function og_content_type_admin_owner()

/**
 * Submit the group/content-type associations for storage
 *  
 * @param string $form_id
 * @param mixed $form_values
 */
function og_content_type_admin_owner_submit($form, &$form_state) {
  $form_values = $form_state['values']; 	
  //check if the group is already monitored, if not INSERT it; if so, UPDATE it.
  if (is_numeric(arg(1))) {
    $group = node_load(arg(1));
    if ($group) {
      if (db_fetch_object(db_query("SELECT octa.gid FROM {og_content_type_admin} octa WHERE octa.gid = %d", $group->nid))) {
        $query = db_query("UPDATE {og_content_type_admin} SET types_active = '%s' WHERE name = '%s'", serialize($form_values['group']), $group->title);
      }
      else {
        $allowed = db_fetch_object(db_query("SELECT octa.types_allowed FROM {og_content_type_admin} octa WHERE octa.gid = %d", 0));
        $query = db_query("INSERT INTO {og_content_type_admin} (gid, name, types_allowed, types_active) VALUES (%d, '%s', '%s', '%s')",
          $group->nid, $group->title, $allowed->types_allowed, serialize($form_values['group']));
      }
      if (!$query) {
        drupal_set_message(t('There was an error processing the data. Try again, or contact your site administrator.'), 'error');
      }
      else {
        drupal_set_message(t('The changes have been saved.'));
      }
    }
  }
} //function og_content_type_admin_owner_submit()

/**
 * Theme function to display the group/content-type association grid
 * 
 * @param $form The form for the table.
 * @return string An HTML string representing the table.
 */
function theme_og_content_type_admin_owner($form) {
  //header is common for each group we work with
  $header[] = (t('Content Types'));
  $header[] = (t('Active'));
  $output = '';
  $rows = array();
  if (is_array($form['group'])) {
    foreach (element_children($form['group']) as $type) { //grab a content type
      if ($form['group'][$type]['#type'] != 'hidden') {
        $row = array();
        $node_type = node_get_types('type', $type);
        $row[] = array('data' => $node_type->name, 'class' => 'role'); //re-use the role CSS style
        $row[] = array('data' => drupal_render($form['group'][$type]), 'align' => 'left', 'title' => t($type));
        $rows[] = $row;
      }
    }
  }
  $fieldset = array(
    '#type' => 'fieldset',
    '#value' => theme('table', $header, $rows, array('id' => 'roles')),// re-use the roles CSS style
    '#title' => 'Group Content Types',
    '#description' => t('As group owner, you can limit the kinds of content that your group members create in this group by deactivating content types. 
    <h3><strong>You will still be able to use the deactivated content types yourself, even though your group members won\'t.</strong></h3>
    Your site admin may give you recommendations.
    Disabled items are <em>required</em> by the site admin.'),
    );
  $output .= theme('fieldset', $fieldset);
  $output .= drupal_render($form);
  return $output;
} //function theme_og_content_type_admin_owner()

  //This section contains all processing to make sure that only the authorized content types are useable in
  //each situation that may come up

/**
 * Remove content menu items based on the 'site-wide' settings set in og_content_type_admin_admin.
 * 
 * This function removes from the 'Create content' menu any types which should not be available site-wide.
 * This has the effect of requiring that the removed types, if used at all, be associated with groups; i.e.
 * those content types cannot be publicly viewable as they will have a group context. This of course, depends
 * on how the admin sets the audience settings. If only admins can cross-post and mark group postings as public,
 * then this will all work as designed. This function does not remove illegal content types from the node/add
 * page's listing, nor does it remove the menu items within the OG 'group detail' menu. It also doesn't account
 * for directly entering in an illegal url. Other functions handle these problems.
 */
function og_content_type_admin_menu_alter(&$callbacks) {
  global $user;
  // First: Replace access callback to all content types and handle all create content pages.
  $types = node_get_types();
  foreach ($types as $type) {
  	$type = $type->type; 
  	$node_type = isset($type) ? str_replace('_', '-', $type) : NULL; 
    $type_path = "node/add/$node_type"; 
    $old_callback = $callbacks[$type_path]['access callback'];
    $old_args = $callbacks[$type_path]['access arguments'];
    array_unshift($old_args, $old_callback);
    array_unshift($old_args, 2); // we need to get node type for our own processing
    $callbacks[$type_path]['access callback'] = 'og_content_type_admin_menu_access';
    $callbacks[$type_path]['access arguments'] = $old_args; // pass original callback and its arguments as parameters
    $callbacks[$type_path]['page callback'] = 'og_content_type_admin_node_add';
  } 
  /*TODO: Would something like the below work above ? 
   *$callbacks[]['access callback'] = FALSE;  
   *$callbacks[]['page callback'] = 'og_content_type_admin_node_add';
   */
  $callbacks['node/add']['page callback'] = 'og_content_type_admin_node_add'; 
}

/**
 * mnode/add access callback override. If gid is present check og_content_type access rights. Otherwise pass processing to original function
 */
function og_content_type_admin_menu_access() { 
  $args = func_get_args();
  $type = array_shift($args);
  $type = isset($type) ? str_replace('-', '_', $type) : NULL; 
  $original_callback = array_shift($args);
  
  // First: Allow access to add a particlar type of group content 
  if (is_array($_GET['gids'])) {   
    $gid = $_GET['gids'][0];
    $group = node_load($gid);
    $sql = "SELECT octa.types_active, octa.types_allowed FROM {og_content_type_admin} octa WHERE octa.gid = %d";
    //if we're keeping track of this group, get it's active types, otherwise, get the defaults
    $types = db_fetch_object(db_query($sql, $gid));
    if (!$types) {  
      $types = db_fetch_object(db_query($sql, 0)); 
    }
    if (_og_content_type_admin_is_admin($group)) { 
      $active_types = unserialize($types->types_allowed);
    } else {
	  $active_types = unserialize($types->types_active);
	} 
    if ($active_types[$type]) {
      return TRUE;
    }	
  }
  else { // do normal processing plus 'allowed' check
    $sql = "SELECT octa.types_allowed FROM {og_content_type_admin} octa WHERE octa.gid = -1";  
    $types = db_fetch_object(db_query($sql));
    $allowed_types = unserialize($types->types_allowed);     
    if ($allowed_types[$type] && call_user_func_array($original_callback, $args)) {  
      return TRUE;
    }   
  }
  return FALSE;
}
 /**
 * Interception of the node module's node_add function.
 * 
 * Present a node submission form or a set of links to such forms.
 */
function og_content_type_admin_node_add($type = NULL) {  // we are only coming here for node/add
  global $user, $_GET;  
  //if there is a group context, get the active types for the group, otherwise, use the site-wide list
  if (is_array($_GET[gids])) {
    $gid = $_GET[gids][0];
    $sql = "SELECT octa.types_active, octa.types_allowed FROM {og_content_type_admin} octa WHERE octa.gid = %d";
    //if we're keeping track of this group, get it's active types, otherwise, get the defaults
    if (!$result = db_fetch_object(db_query($sql, $gid))) {
      $result = db_fetch_object(db_query($sql, 0));
    }
    $activated_types = unserialize($result->types_active);
    $allowed_types = unserialize($result->types_allowed);
    $look_at_allowed = 1;
  }
  else {
  $sql = "SELECT octa.types_active FROM {og_content_type_admin} octa WHERE octa.gid = -1";
  $result = db_fetch_object(db_query($sql));
  $activated_types = unserialize($result->types_active);
  $look_at_allowed = 0;
  }  
  $types = node_get_types(); 
  $type = isset($type) ? str_replace('-', '_', $type) : NULL;
  $allowed_for_group_admins = (($allowed_types[$type] != NOT_ASSIGNED_TO_GROUP) && (_og_content_type_admin_is_admin_content_access_nid($gid)));
  $allowed_for_users = (($activated_types[$type] != DEACTIVATED) && (!_og_content_type_admin_is_admin_content_access_nid($gid)));
  
  // If a node type has been specified, validate its existence and output the form if authorized.
  // If the user is site admin, allow all content types.
  if (($user->uid == 1) && isset($types[$type])) {
    // Initialize settings:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);
    drupal_set_title(t('Submit @name', array('@name' => $types[$type]->name)));
    $output = drupal_get_form($type. '_node_form', $node);
  }// If we don't know the gid, then use site-wide types. Only allow types that aren't DEACTIVATED.
  elseif (($look_at_allowed == 0) && isset($types[$type]) && node_access('create', $type) && ($activated_types[$type] != DEACTIVATED)) {
    // Initialize settings:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);
    drupal_set_title(t('Submit @name', array('@name' => $types[$type]->name)));
    $output = drupal_get_form($type. '_node_form', $node);
   // TODO: if and elseif have the same logic
  }// If we have the gid, check if the user is a group admin. If so, allow them to create ALLOWED types that are not ACTIVATED for their group members.
  // Otherwise, if the user is not a group admin, they can only create types that are not DEACTIVATED.   
  elseif (($look_at_allowed == 1) && isset($types[$type]) && node_access('create', $type) && ($allowed_for_group_admins || $allowed_for_users)) {
    // Initialize settings:
    $node = array('uid' => $user->uid, 'name' => $user->name, 'type' => $type);
    drupal_set_title(t('Submit @name', array('@name' => $types[$type]->name)));
    $output = drupal_get_form($type. '_node_form', $node);   
   // TODO: if and elseif(2) have the same logic 
  }
  else { 
    // If no (valid) node type has been provided, display a node type overview.
    // Make sure to use the site-wide settings since we're on the node/add page in this case.
    drupal_set_title(t('Create content'));
    foreach ($types as $type) {
      if (function_exists($type->module. '_form') && node_access('create', $type->type) && (($activated_types[$type->type] != DEACTIVATED) || ($user->uid == 1))) {
        $type_url_str = str_replace('_', '-', $type->type);
        $title = t('Add a new @s.', array('@s' => $type->name));
        if ($gid != NULL) {
          $out = '<dt>' .l(drupal_ucfirst($type->name), "node/add/$type_url_str", array('query' => "gids[]=$gid")). '</dt>'; 
        }
        else { 
          $out = '<dt>' .l(drupal_ucfirst($type->name), "node/add/$type_url_str"). '</dt>';
        }
        $out .= '<dd>' .filter_xss_admin($type->description). '</dd>';
        $item[$type->type] = $out;
      }
    }

    if (isset($item)) {
      uksort($item, 'strnatcasecmp');
      $output = t('Choose the appropriate item from the list:'). '<dl>' .implode('', $item). '</dl>';
    }
    else {
      drupal_set_title(t('Invalid Content Type'));
      $output = t('Either the content type you are trying to create does not exist,
       or you are not authorized to access the content type you have tried to create in the current context.
        \'Create\' a content type by selecting from either the group menu or the \'Create content\' menu instead.');
    }
  }

  return $output;
}
  
/**
 * Implementation of hook_block(). See og_content_type_admin_block_details.
 */
function og_content_type_admin_block($op = 'list', $delta = 0, $edit = array()) {
  if ($op == 'list') {
    $blocks[0]['info'] = t('Group details override by OG Content Type Admin');
    
    // Auto-enable the group blocks for fresh installations.
    $blocks[0]['status'] = 1;
    $blocks[0]['weight'] = -2;
    
    return $blocks;
  }
  elseif ($op == 'view') {
    switch ($delta) {
      case 0:
        return og_content_type_admin_block_details();
    }
  }
} // function og_content_type_admin_block()

/**
 * We want admins to use this instead of og_block_details().
 * 
 * Upon installation, we read og_block_details' settings, disable it, and assign those settings to this block.
 * Upon uninstallation, we reverse the process.
 */
function og_content_type_admin_block_details() {
  global $user;

  if ($node = og_get_group_context()) {
  	$cntall = db_result(db_query(og_list_users_sql(0, 0, 'u.name ASC', TRUE), $node->nid));
    $result = db_query(og_list_users_sql(0), $node->nid);
    $cntpending = 0;
    while ($row = db_fetch_object($result)) {
      if ($row->is_active == 0) {
        $cntpending++;
      }
      if ($row->uid == $user->uid) {
        if ($row->is_active) {
          $subscription = 'active';
        }
        else {
          $subscription = 'requested';
        }
      }
    }

    $links[] = l(t('Group home'), "node/$node->nid");
    
    if ($subscription == 'active' || user_access('administer nodes')) {
      $links2 = module_invoke_all('og_create_links', $node);
      $links = array_merge($links, $links2);
      $sql = "SELECT octa.types_active, octa.types_allowed FROM {og_content_type_admin} octa WHERE octa.gid = %d";
      //if we're keeping track of this group, get it's active types, otherwise, get the defaults
      if (!$result = db_fetch_object(db_query($sql, $node->nid))) {
        $result = db_fetch_object(db_query($sql, 0));
      }
      $activated_types = unserialize($result->types_active); //print_r($activated_types);      
      $allowed_types = unserialize($result->types_allowed);
      $types = node_get_types();
      //sift through the links returned and remove the restricted content types
      foreach ($types as $type) {
        foreach ($links as $link => $value) {
          $link_test_text = t('Create !type', array('!type' => $type->name));
          if (strstr($value, $link_test_text) && ($activated_types[$type->type] == DEACTIVATED) && (!_og_content_type_admin_is_admin_content_access_nid($node->nid))) {
            unset($links[$link]);
          }
          if (strstr($value, $link_test_text) && ($allowed_types[$type->type] == NOT_ASSIGNED_TO_GROUP) && ($user->uid != 1)) {
            unset($links[$link]);
          }
        }
      }
      
      if ($node->og_selective < OG_INVITE_ONLY) {
        $links[] = l(t('Invite friend'), "og/invite/$node->nid");
      }
      $txt = format_plural($cntall-$cntpending, '1 member', '@count members');
      $txt = og_is_picture() ? l($txt, "og/users/$node->nid/faces") : l($txt, "og/users/$node->nid");
      $txt .= $cntpending ? " ($cntpending)" : '';
      $links[] = $txt;
      $links[] =  t('Manager: '). theme('username', $node);
      $links[] = isset($subscription) ? l(t('My membership'), "og/manage/$node->nid") : og_subscribe_link($node);
      if (isset($node->og_website) && !empty($node->og_website)) {
        $links[] = l(t('website'), $node->og_website);
      }
      if (module_exists('search') && user_access('search content')) {
        $post = drupal_get_form('og_content_type_admin_search_form', $node);
      }
    }
    elseif ($subscription == 'requested') {
      $links[] = t('Your membership request awaits approval.');
      $links[] = l(t('delete request'), "og/unsubscribe/$node->nid", array(), 'destination=og');
    }
    elseif (!$user->uid) {
      $dest = array('query' => drupal_get_destination());
      $links[] = t('You must <a href="!register">register</a>/<a href="!login">login</a> in order to post into this group.', array('!register' => url("user/register", $dest), '!login' => url("user/login", $dest)));
    }
    elseif ($node->og_selective < OG_INVITE_ONLY) {
      $links[] = og_subscribe_link($node);
    }
    else {
      $links[] = t('This is a @closed group. The group administrators add/remove members as needed.', array('@closed' => t('closed')));
    }
    $block['content'] = theme('item_list', $links). $post;
    $block['subject'] = l($node->title, "node/$node->nid"); 
    return $block;
  }
} // function og_content_type_admin_block_details()

/**
 * Replacement for og_search_form; make it prettier
 *
 * @param object $group
 * @return array
 */
function og_content_type_admin_search_form($group) {
  $form['filter0'] = array(
    '#type' => 'textfield',
    '#title' => '',
    '#description' => '',
    '#size' => 19,
    '#maxlength' => 255,
    '#attributes' => array('class' => 'group_search'),
  );
  $form['submit'] = array(
    '#type' => 'submit', 
    '#value' => t('Search this group'),
    '#attributes' => array('class' => 'group_search_button'),
  );
  $form['#process'] = array('views_filters_process' => array());
  $form['#method'] = 'get';
  $form['#action'] = url("og/search/$group->nid");
  return $form;
} // function og_content_type_admin_search_form

/**
 * Implementation of hook_nodeapi
 * 
 * We need to update group name changes.
 * We need to remove from our table any reference to a deleted group.
 * 
 */
function og_content_type_admin_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'update':
      if ($group = db_fetch_object(db_query("SELECT nid FROM {og} WHERE nid = %d", $node->nid))) {
        if (db_query("SELECT * FROM {og_content_type_admin} WHERE gid = %d", $group->nid)) {
          $sql = "UPDATE {og_content_type_admin} SET name = '%s' WHERE gid = %d";
          $result = db_query($sql, $node->title, $group->nid);
          if (!$result) {
            drupal_set_message('Problem updating the group name for the OG Content Type Admin table.', 'error');
          }
        }
      }
      break;
    case 'delete':
      if ($group = db_fetch_object(db_query("SELECT nid FROM {og} WHERE nid = %d", $node->nid))) {
        if (db_query("SELECT * FROM {og_content_type_admin} WHERE gid = %d", $group->nid)) {
          $sql = "DELETE FROM {og_content_type_admin} WHERE gid = %d";
          $result = db_query($sql, $group->nid);
          if (!$result) {
            drupal_set_message('Problem removing a reference to the deleted group from the OG Content Type Admin table.', 'error');
          }
        }
      }
      break;
  }
} // function og_content_type_admin_nodeapi()

/**
 * Implementation of hook_node_type.
 * 
 * Intercept creation or deletion of node types and add/delete references to them in our DB table.
 * @param string $op The operation being performed on $info.
 * @param object $info The node type object on which $op is being performed.
 */
function og_content_type_admin_node_type($op, $info) {
  switch ($op) { //in any case, just rebuild the entire table
    case 'update':
    case 'insert':
    case 'delete':
      _og_content_type_admin_rebuild_table($op, $info);
      break;
  }
} // function og_content_type_admin_node_type()

/**
 * Implementation of hook_form_alter
 * 
 * We need to add a #submit function callback to the og_admin_settings form so that we can update our table
 * when the 'Omitted content types' and/or 'Group home page node types' are changed on the Organic Groups
 * administration settings.
 */
function og_content_type_admin_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'og_admin_settings') {
    $form['#submit']['_og_content_type_admin_rebuild_table'] = array();
  }
  elseif (isset($form['type']) && $form['type']['#value']. '_node_form' == $form_id) {
    $group = new stdClass;  // used for call _og_content_type_admin_is_admin()
    if (!empty($form['og_nodeapi']['visible']['og_groups']['#options'])) {
      foreach ($form['og_nodeapi']['visible']['og_groups']['#options'] as $nid => $name) {
        //see if they can add this content-type for this group
        $group->nid = $nid;
        if (_og_content_type_admin_is_admin($group)) { 
          continue;
        }
        else {
          //see if they are allowed to add this content type
          $sql = "SELECT octa.types_active FROM {og_content_type_admin} octa WHERE octa.gid = %d";
          if (!$result = db_fetch_object(db_query($sql, $nid))) {
            $result = db_fetch_object(db_query($sql, 0));
          }
          $activated_types = unserialize($result->types_active);
          if (empty($activated_types->{$form['type']['#value']})) {
            unset($form['og_nodeapi']['visible']['og_groups']['#options'][$nid]); // remove the checkbox to add this content to the og
          }
        }
      }
    }
  }
} // function og_content_type_admin_form_alter()

  //Helper/ utility functions-------------------------------------------------------------------------------
  //Functions that help those above and don't accomplish directly any of the design items

/**
 * Return an array containing all groups that we're monitoring. Suitable for a form item.
 */
function _og_content_type_admin_get_added() {
  $sql = "SELECT octa.gid, octa.name FROM {og_content_type_admin} octa ORDER BY octa.name ASC";
  $result = db_query($sql);
  while ($row = db_fetch_object($result)) {
    $options[$row->gid] = $row->name;
  }
  return $options ? $options : array();
} // function _og_content_type_admin_get_added()

/**
 * Check if a user is a group manager of the given group
 */
function _og_content_type_admin_is_admin($group) {
  global $user;
  if ($user->uid == 1) return TRUE;
  if (variable_get('og_content_type_admin_no_change', 0)) {
    return FALSE;
  }
  $result = db_query(og_list_users_sql(0), $group->nid);
  while ($row = db_fetch_object($result)) {
    if ($row->uid == $user->uid) {
      if ($row->is_admin > 0) return TRUE;
    }
  }
  return FALSE;
} // function _og_content_type_admin_is_admin()

/**
 * Check if a user is a group manager of the given group given a node id
 * and allow access to ALLOWED types, even if the admin hasn't let his users.
 * This way, group admins can use more content types and users can only read
 * them.
 */
function _og_content_type_admin_is_admin_content_access_nid($nid) {
  global $user;
  if ($user->uid == 1) return TRUE;
  $result = db_query(og_list_users_sql(0), $nid);
  while ($row = db_fetch_object($result)) {
    if ($row->uid == $user->uid) {
      if ($row->is_admin > 0) {
        return TRUE;
      }
    }
  }
  return FALSE;
} // function _og_content_type_admin_is_admin_content_access_nid()

/**
 * A table rebuild function for use when either the global group type exemptions change, or when a type is created or deleted from the system.
 * 
 * @param string $op The operation being performed on $info.
 * @param object $info The node type object on which $op is being performed.
 */
function _og_content_type_admin_rebuild_table($op = NULL, $info = NULL) {
//drupal_set_message('<pre>Operation: ' .print_r($op, TRUE). '</pre>');
//drupal_set_message('<pre>Information: ' .print_r($info, TRUE). '</pre>');
  $node_types = node_get_types(); //get all types
  if (($op == 'insert') && ($info != NULL) && (!isset($node_types[$info->type]))) {
    $node_types[$info->type] = $info;
  }
  if (($op == 'update') && empty($info->old_type)) {
    return;
  }
  if ($op == 'delete') {//we're never getting here since Drupal isn't deleting uninstalled content types
    unset($node_types[$info->type]);
  }
  $sql = "SELECT octa.gid, octa.name, octa.types_allowed, octa.types_active FROM {og_content_type_admin} octa ORDER BY octa.name ASC";
  $results = db_query($sql);
  $bad_query = FALSE;
  while ($result = db_fetch_object($results)) {
    $old_allowed = unserialize($result->types_allowed);
    $old_active = unserialize($result->types_active);
    if ($result->gid == -1) { //site-wide could have all types
      foreach ($node_types as $type) {
        if (!empty($info->old_type) && ($type->type == $info->old_type)) {//if the name of the type is changing
          $ntype = $info->type;
          $otype = $info->old_type;
        }
        else {
          $ntype = $otype = $type->type;
        }
        if (isset($old_allowed[$otype])) {//if settings already exist, copy them
          $new_allowed[$ntype] = $old_allowed[$otype];
        }
        else {
          $new_allowed[$ntype] = NOT_ASSIGNED_TO_GROUP;
        }
        if (isset($old_active[$otype])) {//if settings already exist, copy them
          $new_active[$ntype] = $old_active[$otype]; 
        }
        else {
          $new_active[$ntype] = DEACTIVATED;
        }
      }
    }
    else { //honor group type exemptions from group settings in admin
      foreach ($node_types as $type) {
        if (!og_is_omitted_type($type->type) && !og_is_group_type($type->type)) {
          if (!empty($info->old_type) && ($type->type == $info->old_type)) {//if the name of the type is changing
            $ntype = $info->type;
            $otype = $info->old_type;
          }
          else {
            $ntype = $otype = $type->type;
          }
          if (isset($old_allowed[$otype])) {//if settings already exist, copy them
            $new_allowed[$ntype] = $old_allowed[$otype];
          }
          else {
            $new_allowed[$ntype] = NOT_ASSIGNED_TO_GROUP;
          }
          if (isset($old_active[$otype])) {//if settings already exist, copy them
            $new_active[$ntype] = $old_active[$otype]; 
          }
          else {
            $new_active[$ntype] = DEACTIVATED;
          }
        }
      }
    }
    $sql = "UPDATE {og_content_type_admin} SET types_allowed = '%s', types_active = '%s' WHERE gid = %d";
    $query = db_query($sql, serialize($new_allowed), serialize($new_active), $result->gid);
    if (!$query) {
      $bad_query = TRUE;
    }
  }
  if (!$bad_query) {
    drupal_set_message('The og_content_type_admin table was updated');
    if ($op =='insert') {
      drupal_set_message('The new type must be <em>ALLOWED</em> or <em>REQUIRED</em> in the ' .l('admin settings', 'admin/og/og_content_types'). '.');
    }
  }
  else {
    drupal_set_message('There was a problem updating the og_content_type_admin table', 'error');
  }
} // function _og_content_type_admin_rebuild_table()
